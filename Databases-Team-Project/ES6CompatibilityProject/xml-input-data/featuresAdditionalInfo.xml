<?xml version="1.0" encoding="utf-8"?>
<features>
  <feature>
    <featureCategory>Optimisation</featureCategory>
    <name>direct recursion</name>
    <sampleCode>"use strict";return (function f(n){  if (n <= 0) {    return  "foo";  }  return f(n - 1);}(1e6)) === "foo";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
    </sampleCode>
  </feature>
  <feature>
    <featureCategory>Optimisation</featureCategory>
    <name>mutual recursion</name>
    <sampleCode>"use strict";function f(n){  if (n <= 0) {    return  "foo";  }  return g(n - 1);}function g(n){  if (n <= 0) {    return  "bar";  }  return f(n - 1);}return f(1e6) === "foo"  f(1e6+1) === "bar";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
    </sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>basic functionality</name>
    <sampleCode>return (function (a = 1, b = 2) { return a === 3 && b === 2; }(3));</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>explicit undefined defers to the default</name>
    <sampleCode>return (function (a = 1, b = 2) { return a === 1 && b === 3; }(undefined, 3));</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>defaults can refer to previous params</name>
    <sampleCode>return (function (a, b = a) { return b === 5; }(5));</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>arguments object interaction</name>
    <sampleCode>return (function (a = "baz", b = "qux", c = "quux") {  a = "corge";  // The arguments object is not mapped to the  // parameters, even outside of strict mode.  return arguments.length === 2    && arguments[0] === "foo"    && arguments[1] === "bar";}("foo", "bar"));</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>temporal dead zone</name>
    <sampleCode>return (function(x = 1) {  try {    eval("(function(a=a){}())");    return false;  } catch(e) {}  try {    eval("(function(a=b,b){}())");    return false;  } catch(e) {}  return true;}());</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>separate scope</name>
    <sampleCode>return (function(a=function(){  return typeof b === 'undefined';}){  var b = 1;  return a();}());</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>new Function() support</name>
    <sampleCode>return new Function("a = 1", "b = 2",  "return a === 3 && b === 2;")(3);</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>basic functionality</name>
    <sampleCode>return (function (foo, ...args) {  return args instanceof Array && args + "" === "bar,baz";}("foo", "bar", "baz"));</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>function 'length' property</name>
    <sampleCode>return function(a, ...b){}.length === 1 && function(...c){}.length === 0;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>arguments object interaction</name>
    <sampleCode>return (function (foo, ...args) {  foo = "qux";  // The arguments object is not mapped to the  // parameters, even outside of strict mode.  return arguments.length === 3    && arguments[0] === "foo"    && arguments[1] === "bar"    && arguments[2] === "baz";}("foo", "bar", "baz"));</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>can't be used in setters</name>
    <sampleCode>return (function (...args) {  try {    eval("({set e(...args){}})");  } catch(e) {    return true;  }}());</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>new Function() support</name>
    <sampleCode>return new Function("a", "...b",  "return b instanceof Array && a+b === 'foobar,baz';")('foo','bar','baz');</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with arrays, in function calls</name>
    <sampleCode>return Math.max(...[1, 2, 3]) === 3</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with arrays, in array literals</name>
    <sampleCode>return [...[1, 2, 3]][2] === 3;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with sparse arrays, in function calls</name>
    <sampleCode>var a = Array(...[,,]);return "0" in a && "1" in a && '' + a[0] + a[1] === "undefinedundefined";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with sparse arrays, in array literals</name>
    <sampleCode>var a = [...[,,]];return "0" in a && "1" in a && '' + a[0] + a[1] === "undefinedundefined";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with strings, in function calls</name>
    <sampleCode>return Math.max(..."1234") === 4;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with strings, in array literals</name>
    <sampleCode>return ["a", ..."bcd", "e"][3] === "d";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with astral plane strings, in function calls</name>
    <sampleCode>return Array(..."𠮷𠮶")[0] === "𠮷";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with astral plane strings, in array literals</name>
    <sampleCode>return [..."𠮷𠮶"][0] === "𠮷";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with generator instances, in calls</name>
    <sampleCode>var iterable = (function*(){ yield 1; yield 2; yield 3; }());return Math.max(...iterable) === 3;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with generator instances, in arrays</name>
    <sampleCode>var iterable = (function*(){ yield "b"; yield "c"; yield "d"; }());return ["a", ...iterable, "e"][3] === "d";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with generic iterables, in calls</name>
    <sampleCode>var iterable = global.__createIterableObject([1, 2, 3]);return Math.max(...iterable) === 3;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with generic iterables, in arrays</name>
    <sampleCode>var iterable = global.__createIterableObject(["b", "c", "d"]);return ["a", ...iterable, "e"][3] === "d";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with instances of iterables, in calls</name>
    <sampleCode>var iterable = global.__createIterableObject([1, 2, 3]);return Math.max(...Object.create(iterable)) === 3;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with instances of iterables, in arrays</name>
    <sampleCode>var iterable = global.__createIterableObject(["b", "c", "d"]);return ["a", ...Object.create(iterable), "e"][3] === "d";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>spreading non-iterables is a runtime error</name>
    <sampleCode>try {  Math.max(...2);} catch(e) {  return Math.max(...[1, 2, 3]) === 3;}</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>computed properties</name>
    <sampleCode>var x = 'y';return ({ [x]: 1 }).y === 1;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>shorthand properties</name>
    <sampleCode>var a = 7, b = 8, c = {a,b};return c.a === 7 && c.b === 8;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>shorthand methods</name>
    <sampleCode>return ({ y() { return 2; } }).y() === 2;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>string-keyed shorthand methods</name>
    <sampleCode>return ({ "foo bar"() { return 4; } })["foo bar"]() === 4;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>computed shorthand methods</name>
    <sampleCode>var x = 'y';return ({ [x](){ return 1 } }).y() === 1;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>computed accessors</name>
    <sampleCode>var x = 'y',    valueSet,    obj = {      get [x] () { return 1 },      set [x] (value) { valueSet = value }    };obj.y = 'foo';return obj.y === 1 && valueSet === 'foo';</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with arrays</name>
    <sampleCode>var arr = [5];for (var item of arr)  return item === 5;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with sparse arrays</name>
    <sampleCode>var arr = [,,];var count = 0;for (var item of arr)  count += (item === undefined);return count === 2;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with strings</name>
    <sampleCode>var str = "";for (var item of "foo")  str += item;return str === "foo";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with astral plane strings</name>
    <sampleCode>var str = "";for (var item of "𠮷𠮶")  str += item + " ";return str === "𠮷 𠮶 ";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with generator instances</name>
    <sampleCode>var result = "";var iterable = (function*(){ yield 1; yield 2; yield 3; }());for (var item of iterable) {  result += item;}return result === "123";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with generic iterables</name>
    <sampleCode>var result = "";var iterable = global.__createIterableObject([1, 2, 3]);for (var item of iterable) {  result += item;}return result === "123";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with instances of generic iterables</name>
    <sampleCode>var result = "";var iterable = global.__createIterableObject([1, 2, 3]);for (var item of Object.create(iterable)) {  result += item;}return result === "123";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>iterator closing, break</name>
    <sampleCode>var closed = false;var iter = __createIterableObject([1, 2, 3], {  'return': function(){ closed = true; return {}; }});for (var it of iter) break;return closed;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>iterator closing, throw</name>
    <sampleCode>var closed = false;var iter = __createIterableObject([1, 2, 3], {  'return': function(){ closed = true; return {}; }});try {  for (var it of iter) throw 0;} catch(e){}return closed;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>octal literals</name>
    <sampleCode>return 0o10 === 8 && 0O10 === 8;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>binary literals</name>
    <sampleCode>return 0b10 === 2 && 0B10 === 2;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>octal supported by Number()</name>
    <sampleCode>return Number('0o1') === 1;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>binary supported by Number()</name>
    <sampleCode>return Number('0b1') === 1;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>basic functionality</name>
    <sampleCode>var a = "ba", b = "QUX";return `foo bar${a + "z"} ${b.toLowerCase()}` === "foo bar\nbaz qux";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>toString conversion</name>
    <sampleCode>var a = {  toString: function() { return "foo"; },  valueOf: function() { return "bar"; },};return `${a}` === "foo";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>tagged template literals</name>
    <sampleCode>var called = false;function fn(parts, a, b) {  called = true;  return parts instanceof Array &&    parts[0]     === "foo"      &&    parts[1]     === "bar\n"    &&    parts.raw[0] === "foo"      &&    parts.raw[1] === "bar\\n"   &&    a === 123                   &&    b === 456;}return fn `foo${123}bar\n${456}` && called;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>passed array is frozen</name>
    <sampleCode>return (function(parts) {  return Object.isFrozen(parts) && Object.isFrozen(parts.raw);}) `foo${0}bar${0}baz`;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>line break normalisation</name>
    <sampleCode>var cr   = eval("`x" + String.fromCharCode(13)    + "y`");var lf   = eval("`x" + String.fromCharCode(10)    + "y`");var crlf = eval("`x" + String.fromCharCode(13,10) + "y`");return cr.length === 3 && lf.length === 3 && crlf.length === 3  && cr[1] === lf[1] && lf[1] === crlf[1] && crlf[1] === '\n';</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>"y" flag</name>
    <sampleCode>var re = new RegExp('\\w', 'y');re.exec('xy');return (re.exec('xy')[0] === 'y');</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>"y" flag, lastIndex</name>
    <sampleCode>var re = new RegExp('yy', 'y');re.lastIndex = 3;var result = re.exec('xxxyyxx')[0];return result === 'yy' && re.lastIndex === 5;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>"u" flag</name>
    <sampleCode>return "𠮷".match(/^.$/u)[0].length === 2;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>"u" flag, Unicode code point escapes</name>
    <sampleCode>return "𝌆".match(/\u{1d306}/u)[0].length === 2;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>"u" flag, case folding</name>
    <sampleCode>return "ſ".match(/S/iu) && "S".match(/ſ/iu);</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with arrays</name>
    <sampleCode>var [a, , [b], c] = [5, null, [6]];return a === 5 && b === 6 && c === undefined;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with sparse arrays</name>
    <sampleCode>var [a, , b] = [,,,];return a === undefined && b === undefined;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with strings</name>
    <sampleCode>var [a, b, c] = "ab";return a === "a" && b === "b" && c === undefined;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with astral plane strings</name>
    <sampleCode>var [c] = "𠮷𠮶";return c === "𠮷";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with generator instances</name>
    <sampleCode>var [a, b, c] = (function*(){ yield 1; yield 2; }());return a === 1 && b === 2 && c === undefined;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with generic iterables</name>
    <sampleCode>var [a, b, c] = global.__createIterableObject([1, 2]);return a === 1 && b === 2 && c === undefined;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with instances of generic iterables</name>
    <sampleCode>var [a, b, c] = Object.create(global.__createIterableObject([1, 2]));return a === 1 && b === 2 && c === undefined;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>iterator closing</name>
    <sampleCode>var closed = false;var iter = global.__createIterableObject([1, 2, 3], {  'return': function(){ closed = true; return {}; }});var [a, b] = iter;return closed;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>trailing commas in iterable patterns</name>
    <sampleCode>var [a,] = [1];return a === 1;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with objects</name>
    <sampleCode>var {c, x:d, e} = {c:7, x:8};return c === 7 && d === 8 && e === undefined;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>object destructuring with primitives</name>
    <sampleCode>var {toFixed} = 2;var {slice} = '';return toFixed === Number.prototype.toFixed  && slice === String.prototype.slice;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>trailing commas in object patterns</name>
    <sampleCode>var {a,} = {a:1};return a === 1;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>throws on null and undefined</name>
    <sampleCode>try {  var {a} = null;  return false;} catch(e) {  if (!(e instanceof TypeError))    return false;}try {  var {b} = undefined;  return false;} catch(e) {  if (!(e instanceof TypeError))    return false;}return true;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>computed properties</name>
    <sampleCode>var qux = "corge";var { [qux]: grault } = { corge: "garply" };return grault === "garply";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>multiples in a single var statement</name>
    <sampleCode>var [a,b] = [5,6], {c,d} = {c:7,d:8};return a === 5 && b === 6 && c === 7 && d === 8;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>nested</name>
    <sampleCode>var [e, {x:f, g}] = [9, {x:10}];var {h, x:[i]} = {h:11, x:[12]};return e === 9 && f === 10 && g === undefined  && h === 11 && i === 12;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>in for-in loop heads</name>
    <sampleCode>for(var [i, j, k] in { qux: 1 }) {  return i === "q" && j === "u" && k === "x";}</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>in for-of loop heads</name>
    <sampleCode>for(var [i, j, k] of [[1,2,3]]) {  return i === 1 && j === 2 && k === 3;}</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>in catch heads</name>
    <sampleCode>try {  throw [1,2];} catch([i,j]) {  try {    throw { k: 3, l: 4 };  } catch({k, l}) {    return i === 1 && j === 2 && k === 3 && l === 4;  }}</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>rest</name>
    <sampleCode>var [a, ...b] = [3, 4, 5];var [c, ...d] = [6];return a === 3 && b instanceof Array && (b + "") === "4,5" &&   c === 6 && d instanceof Array && d.length === 0;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>defaults</name>
    <sampleCode>var {a = 1, b = 0, z:c = 3} = {b:2, z:undefined};var [d = 0, e = 5, f = 6] = [4,,undefined];return a === 1 && b === 2 && c === 3  && d === 4 && e === 5 && f === 6;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>defaults, let temporal dead zone</name>
    <sampleCode>var {a, b = 2} = {a:1};try {  eval("let {c = c} = {};");  return false;} catch(e){}try {  eval("let {c = d, d} = {d:1};");  return false;} catch(e){}return a === 1 && b === 2;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with arrays</name>
    <sampleCode>var a,b,c;[a, , [b], c] = [5, null, [6]];return a === 5 && b === 6 && c === undefined;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with sparse arrays</name>
    <sampleCode>var a, b;[a, , b] = [,,,];return a === undefined && b === undefined;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with strings</name>
    <sampleCode>var a,b,c;[a, b, c] = "ab";return a === "a" && b === "b" && c === undefined;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with astral plane strings</name>
    <sampleCode>var c;[c] = "𠮷𠮶";return c === "𠮷";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with generator instances</name>
    <sampleCode>var a,b,c;[a, b, c] = (function*(){ yield 1; yield 2; }());return a === 1 && b === 2 && c === undefined;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with generic iterables</name>
    <sampleCode>var a,b,c;[a, b, c] = global.__createIterableObject([1, 2]);return a === 1 && b === 2 && c === undefined;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with instances of generic iterables</name>
    <sampleCode>var a,b,c;[a, b, c] = Object.create(global.__createIterableObject([1, 2]));return a === 1 && b === 2 && c === undefined;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>iterator closing</name>
    <sampleCode>var closed = false;var iter = global.__createIterableObject([1, 2, 3], {  'return': function(){ closed = true; return {}; }});var a,b;[a, b] = iter;return closed;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>iterable destructuring expression</name>
    <sampleCode>var a, b, iterable = [1,2];return ([a, b] = iterable) === iterable;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>chained iterable destructuring</name>
    <sampleCode>var a,b,c,d;[a,b] = [c,d] = [1,2];return a === 1 && b === 2 && c === 1 && d === 2;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>trailing commas in iterable patterns</name>
    <sampleCode>var a;[a,] = [1];return a === 1;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with objects</name>
    <sampleCode>var c,d,e;({c, x:d, e} = {c:7, x:8});return c === 7 && d === 8 && e === undefined;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>object destructuring with primitives</name>
    <sampleCode>var toFixed, slice;({toFixed} = 2);({slice} = '');return toFixed === Number.prototype.toFixed  && slice === String.prototype.slice;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>trailing commas in object patterns</name>
    <sampleCode>var a;({a,} = {a:1});return a === 1;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>object destructuring expression</name>
    <sampleCode>var a, b, obj = { a:1, b:2 };return ({a,b} = obj) === obj;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>parenthesised left-hand-side is a syntax error</name>
    <sampleCode>var a, b;({a,b} = {a:1,b:2});try {  eval("({a,b}) = {a:3,b:4};");}catch(e) {  return a === 1 && b === 2;}</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>chained object destructuring</name>
    <sampleCode>var a,b,c,d;({a,b} = {c,d} = {a:1,b:2,c:3,d:4});return a === 1 && b === 2 && c === 3 && d === 4;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>throws on null and undefined</name>
    <sampleCode>var a,b;try {  ({a} = null);  return false;} catch(e) {  if (!(e instanceof TypeError))    return false;}try {  ({b} = undefined);  return false;} catch(e) {  if (!(e instanceof TypeError))    return false;}return true;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>computed properties</name>
    <sampleCode>var grault, qux = "corge";({ [qux]: grault } = { corge: "garply" });return grault === "garply";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>nested</name>
    <sampleCode>var e,f,g,h,i;[e, {x:f, g}] = [9, {x:10}];({h, x:[i]} = {h:11, x:[12]});return e === 9 && f === 10 && g === undefined  && h === 11 && i === 12;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>rest</name>
    <sampleCode>var a,b,c,d;[a, ...b] = [3, 4, 5];[c, ...d] = [6];return a === 3 && b instanceof Array && (b + "") === "4,5" &&   c === 6 && d instanceof Array && d.length === 0;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>nested rest</name>
    <sampleCode>var a = [1, 2, 3], first, last;[first, ...[a[2], last]] = a;return first === 1 && last === 3 && (a + "") === "1,2,2";</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>empty patterns</name>
    <sampleCode>[] = [1,2];({} = {a:1,b:2});return true;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>defaults</name>
    <sampleCode>var a,b,c,d,e,f;({a = 1, b = 0, z:c = 3} = {b:2, z:undefined});[d = 0, e = 5, f = 6] = [4,,undefined];return a === 1 && b === 2 && c === 3  && d === 4 && e === 5 && f === 6;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with arrays</name>
    <sampleCode>return function([a, , [b], c]) {  return a === 5 && b === 6 && c === undefined;}([5, null, [6]]);</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with sparse arrays</name>
    <sampleCode>return function([a, , b]) {  return a === undefined && b === undefined;}([,,,]);</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with strings</name>
    <sampleCode>return function([a, b, c]) {  return a === "a" && b === "b" && c === undefined;}("ab");</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with astral plane strings</name>
    <sampleCode>return function([c]) {  return c === "𠮷";}("𠮷𠮶");</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with generator instances</name>
    <sampleCode>return function([a, b, c]) {  return a === 1 && b === 2 && c === undefined;}(function*(){ yield 1; yield 2; }());</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with generic iterables</name>
    <sampleCode>return function([a, b, c]) {  return a === 1 && b === 2 && c === undefined;}(global.__createIterableObject([1, 2]));</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with instances of generic iterables</name>
    <sampleCode>return function([a, b, c]) {  return a === 1 && b === 2 && c === undefined;}(Object.create(global.__createIterableObject([1, 2])));</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>iterator closing</name>
    <sampleCode>var closed = false;var iter = global.__createIterableObject([1, 2, 3], {  'return': function(){ closed = true; return {}; }});(function([a,b]) {}(iter));return closed;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>trailing commas in iterable patterns</name>
    <sampleCode>return function([a,]) {  return a === 1;}([1]);</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>with objects</name>
    <sampleCode>return function({c, x:d, e}) {  return c === 7 && d === 8 && e === undefined;}({c:7, x:8});</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>object destructuring with primitives</name>
    <sampleCode>return function({toFixed}, {slice}) {  return toFixed === Number.prototype.toFixed    && slice === String.prototype.slice;}(2,'');</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>trailing commas in object patterns</name>
    <sampleCode>return function({a,}) {  return a === 1;}({a:1});</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>throws on null and undefined</name>
    <sampleCode>try {  (function({a}){}(null));  return false;} catch(e) {}try {  (function({b}){}(undefined));  return false;} catch(e) {}return true;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>computed properties</name>
    <sampleCode>var qux = "corge";return function({ [qux]: grault }) {  return grault === "garply";}({ corge: "garply" });</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>nested</name>
    <sampleCode>return function([e, {x:f, g}], {h, x:[i]}) {  return e === 9 && f === 10 && g === undefined    && h === 11 && i === 12;}([9, {x:10}],{h:11, x:[12]});</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>'arguments' interaction</name>
    <sampleCode>return (function({a, x:b, y:e}, [c, d]) {  return arguments[0].a === 1 && arguments[0].x === 2    && !("y" in arguments[0]) && arguments[1] + '' === "3,4";}({a:1, x:2}, [3, 4]));</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>new Function() support</name>
    <sampleCode>return new Function("{a, x:b, y:e}","[c, d]",  "return a === 1 && b === 2 && c === 3 && "  + "d === 4 && e === undefined;")({a:1, x:2}, [3, 4]);</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name></name>
    <sampleCode></sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>in parameters, function 'length' property</name>
    <sampleCode>return function({a, b}, [c, d]){}.length === 2;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>rest</name>
    <sampleCode>return function([a, ...b], [c, ...d]) {  return a === 3 && b instanceof Array && (b + "") === "4,5" &&     c === 6 && d instanceof Array && d.length === 0;}([3, 4, 5], [6]);</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>empty patterns</name>
    <sampleCode>return function ([],{}){  return arguments[0] + '' === "3,4" && arguments[1].x === "foo";}([3,4],{x:"foo"});</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>defaults</name>
    <sampleCode>return (function({a = 1, b = 0, c = 3, x:d = 0, y:e = 5},    [f = 6, g = 0, h = 8]) {  return a === 1 && b === 2 && c === 3 && d === 4 &&    e === 5 && f === 6 && g === 7 && h === 8;}({b:2, c:undefined, x:4},[, 7, undefined]));</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>defaults, separate scope</name>
    <sampleCode>return (function({a=function(){  return typeof b === 'undefined';}}){  var b = 1;  return a();}({}));</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>defaults, new Function() support</name>
    <sampleCode>return new Function("{a = 1, b = 0, c = 3, x:d = 0, y:e = 5}",  "return a === 1 && b === 2 && c === 3 && d === 4 && e === 5;")({b:2, c:undefined, x:4});</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>in strings</name>
    <sampleCode>return '\u{1d306}' == '\ud834\udf06';</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>in identifiers</name>
    <sampleCode>var \u{102C0} = { \u{102C0} : 2 };return \u{102C0}['\ud800\udec0'] === 2;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>in constructors</name>
    <sampleCode>var passed = false;new function f() {  passed = (new.target === f);}();(function() {  passed &= (new.target === undefined);}());return passed;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Syntax</featureCategory>
    <name>assignment is an early error</name>
    <sampleCode>var passed = false;new function f() {  passed = (new.target === f);}();try {  Function("new.target = function(){};");} catch(e) {  return passed;}</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>basic support</name>
    <sampleCode>const foo = 123;return (foo === 123);</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>is block-scoped</name>
    <sampleCode>const bar = 123;{ const bar = 456; }return bar === 123;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>cannot be in statements</name>
    <sampleCode>const bar = 1;try {  Function("if(true) const baz = 1;")();} catch(e) {  return true;}</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>redefining a const is an error</name>
    <sampleCode>const baz = 1;try {  Function("const foo = 1; foo = 2;")();} catch(e) {  return true;}</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>for loop statement scope</name>
    <sampleCode>const baz = 1;for(const baz = 0; false;) {}return baz === 1;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>for-in loop iteration scope</name>
    <sampleCode>var scopes = [];for(const i in { a:1, b:1 }) {  scopes.push(function(){ return i; });}return (scopes[0]() === "a" && scopes[1]() === "b");</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>for-of loop iteration scope</name>
    <sampleCode>var scopes = [];for(const i of ['a','b']) {  scopes.push(function(){ return i; });}return (scopes[0]() === "a" && scopes[1]() === "b");</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>temporal dead zone</name>
    <sampleCode>var passed = (function(){ try { qux; } catch(e) { return true; }}());function fn() { passed &= qux === 456; }const qux = 456;fn();return passed;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>basic support (strict mode)</name>
    <sampleCode>"use strict";const foo = 123;return (foo === 123);</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>is block-scoped (strict mode)</name>
    <sampleCode>'use strict';const bar = 123;{ const bar = 456; }return bar === 123;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>cannot be in statements (strict mode)</name>
    <sampleCode>'use strict';const bar = 1;try {  Function("'use strict'; if(true) const baz = 1;")();} catch(e) {  return true;}</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>redefining a const (strict mode)</name>
    <sampleCode>'use strict';const baz = 1;try {  Function("'use strict'; const foo = 1; foo = 2;")();} catch(e) {  return true;}</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>for loop statement scope (strict mode)</name>
    <sampleCode>'use strict';const baz = 1;for(const baz = 0; false;) {}return baz === 1;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>for-in loop iteration scope (strict mode) </name>
    <sampleCode>'use strict';var scopes = [];for(const i in { a:1, b:1 }) {  scopes.push(function(){ return i; });}return (scopes[0]() === "a" && scopes[1]() === "b");</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>for-of loop iteration scope (strict mode)</name>
    <sampleCode>'use strict';var scopes = [];for(const i of ['a','b']) {  scopes.push(function(){ return i; });}return (scopes[0]() === "a" && scopes[1]() === "b");</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>temporal dead zone (strict mode)</name>
    <sampleCode>'use strict';var passed = (function(){ try { qux; } catch(e) { return true; }}());function fn() { passed &= qux === 456; }const qux = 456;fn();return passed;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>basic support</name>
    <sampleCode>let foo = 123;return (foo === 123);</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>is block-scoped</name>
    <sampleCode>let bar = 123;{ let bar = 456; }return bar === 123;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>cannot be in statements</name>
    <sampleCode>let bar = 1;try {  Function("if(true) let baz = 1;")();} catch(e) {  return true;}</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>for loop statement scope</name>
    <sampleCode>let baz = 1;for(let baz = 0; false;) {}return baz === 1;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>temporal dead zone</name>
    <sampleCode>var passed = (function(){ try {  qux; } catch(e) { return true; }}());function fn() { passed &= qux === 456; }let qux = 456;fn();return passed;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>for/for-in loop iteration scope</name>
    <sampleCode>let scopes = [];for(let i = 0; i < 2; i++) {  scopes.push(function(){ return i; });}let passed = (scopes[0]() === 0 && scopes[1]() === 1);scopes = [];for(let i in { a:1, b:1 }) {  scopes.push(function(){ return i; });}passed &= (scopes[0]() === "a" && scopes[1]() === "b");return passed;                        
    </sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>basic support (strict mode)</name>
    <sampleCode>'use strict';let foo = 123;return (foo === 123);</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>is block-scoped (strict mode)</name>
    <sampleCode>'use strict';let bar = 123;{ let bar = 456; }return bar === 123;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>cannot be in statements (strict mode)</name>
    <sampleCode>'use strict';let bar = 1;try {  Function("'use strict'; if(true) let baz = 1;")();} catch(e) {  return true;}</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>for loop statement scope (strict mode)</name>
    <sampleCode>'use strict';let baz = 1;for(let baz = 0; false;) {}return baz === 1;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>temporal dead zone (strict mode)</name>
    <sampleCode>'use strict';var passed = (function(){ try {  qux; } catch(e) { return true; }}());function fn() { passed &= qux === 456; }let qux = 456;fn();return passed;</sampleCode>
  </feature>
  <feature>
    <featureCategory>Bindings</featureCategory>
    <name>for/for-in loop iteration scope (strict mode)</name>
    <sampleCode>'use strict';let scopes = [];for(let i = 0; i < 2; i++) {  scopes.push(function(){ return i; });}let passed = (scopes[0]() === 0 && scopes[1]() === 1);scopes = [];for(let i in { a:1, b:1 }) {  scopes.push(function(){ return i; });}passed &= (scopes[0]() === "a" && scopes[1]() === "b");return passed;
    </sampleCode>
  </feature>
</features>